unit sdZeta2;

{Double precision Zeta functions, part 2: less common functions}

interface

{$i std.inc}

{$ifdef BIT16}
{$N+}
{$endif}

{$ifdef NOBASM}
  {$undef BASM}
{$endif}


(*************************************************************************

 DESCRIPTION   :  Double precision Zeta functions, part 2: less common functions

 REQUIREMENTS  :  BP7, D1-D7/D9-D10/D12/D17-D18, FPC, VP, WDOSX

 EXTERNAL DATA :  ---

 MEMORY USAGE  :  ---

 DISPLAY MODE  :  ---

 REMARK        :  ---

 REFERENCES    :  References used in this unit, main index in amath_info.txt/references

                 [22] A.J. MacLeod, MISCFUN: A software package to compute uncommon special functions.
                      ACM Trans. on Math. Soft. 22 (1996), pp.288-301.
                 [33] http://functions.wolfram.com/: Formulas and graphics about
                      mathematical functions for the mathematical and scientific
                      community and/or http://mathworld.wolfram.com/ ("/the web's
                      most extensive mathematical resource/")
                 [47] M. Goano, Algorithm 745: Computation of the complete and incomplete
                      Fermi-Dirac integral. ACM TOMS, Vol.21, No.3, 1995, pp.221-232.
                      Fortran source available from http://netlib.org/toms/745

 Version  Date      Author      Modification
 -------  --------  -------     ------------------------------------------
 1.12.00  16.06.14  W.Ehrhardt  New unit with Fermi/Dirac, Lobachewsky, harmonic functions

 1.18.00  26.06.15  we          Fix: Type double in sfd_fdp25 and harm2core

***************************************************************************)


(*-------------------------------------------------------------------------
 (C) Copyright 2009-2015 Wolfgang Ehrhardt

 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from
 the use of this software.

 Permission is granted to anyone to use this software for any purpose,
 including commercial applications, and to alter it and redistribute it
 freely, subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software in
    a product, an acknowledgment in the product documentation would be
    appreciated but is not required.

 2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

 3. This notice may not be removed or altered from any source distribution.
----------------------------------------------------------------------------*)

(*-------------------------------------------------------------------------
  This Pascal code uses material and ideas from open source and public
  domain libraries, see the file '3rdparty.ama' for the licenses.
---------------------------------------------------------------------------*)


function sfd_fermi_dirac(n: integer; x: double): double;
  {-Return the integer order Fermi-Dirac integral F_n(x) = 1/n!*integral(t^n/(exp(t-x)+1), t=0..INF)}

function sfd_fdm05(x: double): double;
  {-Return the complete Fermi-Dirac integral F(-1/2,x)}

function sfd_fdp05(x: double): double;
  {-Return the complete Fermi-Dirac integral F(1/2,x)}

function sfd_fdp15(x: double): double;
  {-Return the complete Fermi-Dirac integral F(3/2,x)}

function sfd_fdp25(x: double): double;
  {-Return the complete Fermi-Dirac integral F(5/2,x)}

function sfd_harmonic(x: double): double;
  {-Return the harmonic function H(x) = psi(x+1) + EulerGamma}

function sfd_harmonic2(x,r: double): double;
  {-Return the generalized harmonic function H(x,r) = zeta(r)-zetah(r,x+1); x >= -1}

function sfd_llsi(x: double): double;
  {-Return the Lobachevski function Lambda(x) = integral(-ln(|2sin(t)|), t=0..x)}

function sfd_llci(x: double): double;
  {-Return the Lobachevski function L(x) = integral(-ln(|cos(t)|), t=0..x)}


implementation


uses
  DAMath,
  sdBasic, sdGamma, sdZeta;


{---------------------------------------------------------------------------}
function fd_asymp_exp_int(n: integer; x: double): double;
  {-Fermi-Dirac asymptotic expansion for integer order, n>0, x > ln_MaxDbl}
var
  p,s,t,f,z: double;
  k: integer;
begin
  {Asymptotic expansion Goano [47], (9)}
  if n > x - 10 then begin
    {The AE is valid only if x >> n. The loop below converges e.g. for}
    {n = trunc(ln_MaxDbl), x = ln_MaxDbl+10, but the result is Inf. So}
    {return PosInf_d in this invalid situation for all these cases.}
    fd_asymp_exp_int := PosInf_d;
    exit;
  end;
  s := 1.0;
  p := 1.0;
  k := 0;
  z := sqr(1.0/x);
  f := 2.0*n*(n+1);
  repeat
    {loop entry invariants: p,f,s,t >= 0;  p = pochhammer(1-n,k)}
    f := f*z;
    inc(k,2);
    t := p*sfd_etaint(k)*f;
    s := s+t;
    p := p*(k-n-1)*(k-n);
  until t < eps_d*s;
  f := sfd_taylor(x,n+1);
  fd_asymp_exp_int := f*s;
end;


{---------------------------------------------------------------------------}
function fd_polylog_invf(n: integer; x,z: double): double;
  {-Return polylog(n,x), x<-1, n>2, z = ln(-x)}
var
  p,s,t: double;
  j,k: integer;
begin
  {$ifdef debug}
    if (x >= -1) or (n <2) then RunError(byte(RTE_ArgumentRange));
  {$endif}
  {This is part of the standard polylog code, the only difference is,}
  {that z = ln(-x) is externally supplied to increase accuracy}
  s := 0.0;
  for k:=1 to n div 2 do begin
    j := 2*k;
    p := -sfd_etaint(j);
    j := n-j;
    if j>0 then p := sfd_taylor(z,j)*p;
    s := s + p;
  end;
  t := sfd_polylog(n, 1.0/x);
  if odd(n) then t := -t;
  fd_polylog_invf := 2.0*s - t - sfd_taylor(z,n);
end;


{---------------------------------------------------------------------------}
function sfd_fermi_dirac(n: integer; x: double): double;
  {-Return the integer order Fermi-Dirac integral F_n(x) = 1/n!*integral(t^n/(exp(t-x)+1), t=0..INF)}
var
  z: double;
begin
  {Basic formula is F_n(x) = -polylog(n+1,-exp(x)}
  if x < -ln_MaxDbl then begin
    sfd_fermi_dirac := 0.0;
  end
  else if x > ln_MaxDbl then begin
    {asymptotic Goano [47], (9)}
    if n>0 then sfd_fermi_dirac := fd_asymp_exp_int(n, x)
    else case n of
        0: sfd_fermi_dirac := x;     {ln(1+e^x)   -> x}
       -1: sfd_fermi_dirac := 1.0;   {e^x/(1+e^x) -> 1}
      else sfd_fermi_dirac := 0.0;
    end;
  end
  else begin
    z := -exp(x);
    n := n+1;
    if z<-1.0 then begin
      {case x>0}
      if n<0 then begin
        {Li(-n,z) = (-1)^(n-1) * Li(-n,1/z}
        z := sfd_polylog(n, 1.0/z);
        if odd(n) then z := -z;
        sfd_fermi_dirac := z;
      end
      else if n>2 then sfd_fermi_dirac := -fd_polylog_invf(n, z, x)
      else begin
        {n=0,1,2: sfd_polylog can handle full range}
        sfd_fermi_dirac := -sfd_polylog(n, z);
      end;
    end
    else begin
      { -1 <= z < 0}
      sfd_fermi_dirac := -sfd_polylog(n, z);
    end;
  end;
end;


{---------------------------------------------------------------------------}
function fd_asymp_exp_real(q, x: double): double;
  {-Fermi-Dirac asymptotic expansion for real order q with q > -1, x >> q}
var
  p,s,t,r,f,z: double;
  k: integer;
begin
  {Asymptotic expansion Goano [47], (9)}
  {$ifdef debug}
    if q + 10 > x then begin
      {The AE is valid only if x >> q. Normally used only}
      {for q=-1/2, 1/2, (3/2, 5/2) and x > ~40}
      fd_asymp_exp_real := PosInf_d;
      exit;
    end;
  {$endif}
  s := 1.0;
  p := 1.0;
  k := 0;
  z := sqr(1.0/x);
  f := 2.0*q*(q+1.0);
  t := f*1e20;
  repeat
    {p = pochhammer(1-n,k)}
    f := f*z;
    inc(k,2);
    r := p*sfd_etaint(k)*f;
    if abs(r) <= abs(t) then begin
      {terms of AE are still decreasing}
      t := r;
      s := s+t;
      p := p*((k-1)-q)*(k-q);
    end
    else t := 0.0;
  until abs(t) <= eps_d*abs(s);
  f := power(x,q+1.0)*sfd_rgamma(q+2.0);
  fd_asymp_exp_real := f*s;
end;


{---------------------------------------------------------------------------}
function sfd_fdp05(x: double): double;
  {-Return the complete Fermi-Dirac integral F(1/2,x)}
var
  t: double;

{Note: THexExtW are needed with 16-bit compilers for relative errors}
{less than 5 eps_d, they are not needed for the 32+ bit compilers.}
const
  { t05 := t -> fd(1/2, 12*(t+2))/(12*(t+2))^(3/2);}
  { x=12*(t+2), x=12..36, t=x/12-2                 }
  { chebyshev(t05(t),t=-1..1,1e-20);               }
  np05_2 = 30;
  fdp05x2: array[0..np05_2 - 1] of THexDblW = (
             ($7A80,$D5D2,$26DA,$3FF8),   {+1.509486041300675738888540997560    }
             ($AAC2,$58D5,$71AF,$BF64),   {-0.249561545813512079811039605579e-2 }
             ($CCC6,$5965,$174A,$3F50),   {+0.982115370416634900398147501155e-3 }
             ($F3B5,$D036,$CE33,$BF36),   {-0.347983979931683442238436985807e-3 }
             ($426E,$F345,$7AC5,$3F1E),   {+0.116270381856917279446003317185e-3 }
             ($B9BE,$11D9,$9F88,$BF03),   {-0.374282264886563175294182249759e-4 }
             ($978B,$1FCA,$A194,$3EE8),   {+0.117450554111933012129375923807e-4 }
             ($2182,$A6FB,$5B41,$BECE),   {-0.361877328445089611740599641640e-5 }
             ($6756,$0668,$7454,$3EB2),   {+0.109996838094100301284634122410e-5 }
             ($7026,$E4FC,$355D,$BE96),   {-0.330931901425378656153557493753e-6 }
             ($BFFE,$BFAB,$83AD,$3E7A),   {+0.987737251258776378533216391827e-7 }
             ($80AA,$3F76,$744B,$BE5F),   {-0.292940746917047935446228969668e-7 }
             ($BCD2,$FD8A,$8EB8,$3E42),   {+0.864151410267920646768938404232e-8 }
             ($0808,$8798,$CA8B,$BE25),   {-0.253682857771686895946534432944e-8 }
             ($0E9F,$39AF,$7778,$3E09),   {+0.741177885877868223911943372712e-9 }
             ($2BCE,$924E,$9D21,$BDED),   {-0.215468706377707924304414487698e-9 }
             ($03A9,$C650,$1FF8,$3DD1),   {+0.622999859844165129697643004086e-10}
             ($6CA7,$9365,$B037,$BDB3),   {-0.179064482098473796784605475808e-10}
             ($0E24,$3981,$7D8E,$3D96),   {+0.511373660300697402133999999999e-11}
             ($63E2,$1C58,$847B,$BD79),   {-0.145050214090160134093432434719e-11}
             ($0C23,$402C,$C045,$3D5C),   {+0.408577089407887189170064356955e-12}
             ($F8BB,$247C,$15DE,$BD40),   {-0.114293789551114639267975259137e-12}
             ($9BE7,$5F9E,$E105,$3D21),   {+0.317594630475703386901919669155e-13}
             ($E2F0,$BAE8,$BFBA,$BD03),   {-0.877029250354717665156906845619e-14}
             ($4BC5,$C7AE,$B0F4,$3CE5),   {+0.240821085811104890886594570029e-14}
             ($68FD,$00B9,$B4A4,$BCC7),   {-0.657963336164063747675726341907e-15}
             ($1820,$A388,$CBB6,$3CA9),   {+0.178994011257686697681940768666e-15}
             ($0CDF,$EDD6,$F800,$BC8B),   {-0.485180718104061909634313862435e-16}
             ($7494,$7E16,$3C14,$3C6E),   {+0.131122056316856541233113653119e-16}
             ($B0EF,$78C9,$4D89,$BC50));  {-0.353512334501432389833325039827e-17}
         (*  ($1DDA,$3B8D,$8C43,$3C31),   {+0.951273613288044223998852213460e-18}
             ($997A,$EB38,$DC23,$BC12),   {-0.255599619674429801332567738120e-18}
             ($42F0,$BF5A,$3F3A,$3BF4),   {+0.685994710108645567896702114342e-19}
             ($7426,$BE06,$B7BD,$BBD5),   {-0.183956404622969457008106663899e-19}
             ($34A4,$AF0A,$4814,$3BB7));  {+0.493006328361511158404496844422e-20} *)
var
  fdp05_2: array[0..np05_2 - 1] of double absolute fdp05x2;

const
  { t01 := t -> fd(1/2, 4*(t+2));    }
  { x = 4*(t+2), x=4..12, t = x/4-2  }
  { chebyshev(t01(t),t=-1..1,1e-20); }
  np05_1 = 27;
  fdp05x1: array[0..np05_1 - 1] of THexDblW = (
             ($5132,$CB25,$2F83,$4042),   {+36.3712095195973150393571333426     }
             ($095A,$180B,$1CD4,$4029),   {+12.5563056481811830249567824342     }
             ($9D89,$664E,$BAF8,$3FEA),   {+0.835323524302041720793490203916    }
             ($C107,$146E,$1E4F,$BFA5),   {-0.412468635980776559531897297026e-1 }
             ($7F72,$005F,$DB1F,$3F73),   {+0.484764203972064404543231999918e-2 }
             ($D8B4,$631F,$DDEC,$BF47),   {-0.728359626235761181607282375542e-3 }
             ($7D5A,$6E77,$A7F0,$3F1C),   {+0.109314012312724226246017534127e-3 }
             ($731A,$9E21,$5D80,$BEEB),   {-0.130487650872812128272229904414e-4 }
             ($FD93,$402C,$280F,$3E9A),   {+0.389761965081220490099761304103e-6 }
             ($48B9,$375C,$1760,$3E9C),   {+0.418593166671574474687704852229e-6 }
             ($B568,$A7D4,$EC51,$BE87),   {-0.178241140882781326674081586696e-6 }
             ($C8AD,$E363,$EB34,$3E6A),   {+0.501401270935653913653534971074e-7 }
             ($3A68,$E703,$92A7,$BE48),   {-0.114426363665601208334168909836e-7 }
             ($659A,$EE1E,$D42F,$3E22),   {+0.219196737232486715284670447279e-8 }
             ($3019,$EB00,$1885,$BDF7),   {-0.336088028068196988951049728505e-9 }
             ($1D2C,$2471,$FE0C,$3DC0),   {+0.309089460235051920170794233970e-10}
             ($ABA5,$EF38,$B361,$3D8F),   {+0.360395382713747844307256979851e-11}
             ($F755,$D181,$E8C2,$BD89),   {-0.294553759575921784436627612442e-11}
             ($0616,$9203,$EEB2,$3D71),   {+0.101933962170251609766666666667e-11}
             ($8641,$AB5B,$041A,$BD53),   {-0.270234067190522926130300324494e-12}
             ($A6AA,$C002,$D86B,$3D30),   {+0.598468621686930875020197021442e-13}
             ($4AB3,$1A15,$CCAD,$BD08),   {-0.110131976095155602873469185472e-13}
             ($CC08,$089F,$3598,$3CDB),   {+0.151042240381539761772702788261e-14}
             ($714F,$C518,$2E6F,$BC92),   {-0.630793784338055501351350020007e-16}
             ($50AF,$BD19,$A04E,$BC8D),   {-0.513932671709885284753382122899e-16}
             ($410F,$DCF9,$6D05,$3C7C),   {+0.246555126271970717149547742394e-16}
             ($8328,$AE5C,$936D,$BC61));  {-0.762232826802428016612044204458e-17}
         (*  ($546B,$2405,$8C37,$3C41),   {+0.190252722217962867356929160937e-17}
             ($1179,$76B9,$623E,$BC1D));  {-0.398224281531035871813174429148e-18} *)
var
  fdp05_1: array[0..np05_1 - 1] of double absolute fdp05x1;

const
  { t00 := t -> fd(1/2, 2*(t+1));    }
  { x = 2*(t+1), x=0..4, t = x/2 - 1 }
  { chebyshev(t00(t),t=-1..1,1e-20); }
  np05_0 = 27;
  fdp05x0: array[0..np05_0 - 1] of THexDblW = (
             ($D68C,$51DF,$DF14,$4019),   {+6.46785095146845952843732118348     }
             ($1DD2,$7830,$14EF,$4007),   {+2.88522237679328803577304079965     }
             ($3665,$5278,$12C3,$3FDA),   {+0.407395201241206365841823162781    }
             ($346D,$B14D,$6A55,$BF8A),   {-0.128981299145840220950575776539e-1 }
             ($54B5,$7BAC,$B497,$BF67),   {-0.289373003523482132846797286683e-2 }
             ($F7CA,$CF91,$B98E,$3F4D),   {+0.907129985662663210233804487629e-3 }
             ($35F4,$7CC8,$2D2C,$BF14),   {-0.769670870754619578482136591047e-4 }
             ($30C2,$CC56,$8280,$BEF5),   {-0.205133226436761049829261853507e-4 }
             ($6EE4,$2142,$AF02,$3EDF),   {+0.755396515130974716466786294881e-5 }
             ($104D,$329B,$0C18,$BEA6),   {-0.657059080221453744877807438359e-6 }
             ($4015,$E93C,$74FD,$BE8D),   {-0.219471747991019243265527185292e-6 }
             ($5372,$BDDE,$9255,$3E75),   {+0.803605497409122797720816119775e-7 }
             ($1FD8,$3FF7,$44F5,$BE3C),   {-0.658197496457748650644446730955e-8 }
             ($999D,$26B3,$5AAF,$BE27),   {-0.271879079459221500311994000407e-8 }
             ($483B,$CE4B,$89F6,$3E10),   {+0.962691975768783000937454605612e-9 }
             ($5A8D,$324D,$ABF9,$BDD3),   {-0.715654866752415373221538623120e-10}
             ($5371,$D141,$105A,$BDC4),   {-0.364959955979361731397687347572e-10}
             ($5D32,$3AA9,$3827,$3DAB),   {+0.123779266638284628266366968565e-10}
             ($7BE8,$F3A9,$7C5C,$BD6C),   {-0.809614940976175061407222222221e-12}
             ($871C,$FF85,$2216,$BD62),   {-0.515375501880531288979262837777e-12}
             ($DE15,$0D95,$76BD,$3D47),   {+0.166720484322176377906478380684e-12}
             ($F1DB,$4841,$DAEB,$BD04),   {-0.926154824934769235381753853068e-14}
             ($797D,$E9C7,$F6BC,$BD00),   {-0.753344945832780041274713386623e-14}
             ($1CA3,$E692,$E51F,$3CE4),   {+0.231981301008194528825032891928e-14}
             ($53FD,$8EC6,$0F49,$BC9E),   {-0.104290590578891200329403020712e-15}
             ($32B2,$7283,$4492,$BCA0),   {-0.112880951868285154135078466421e-15}
             ($2034,$B34C,$0DF8,$3C83));  {+0.330544205143281718828522986914e-16}
          (* ($2720,$0711,$8B52,$BC34),   {-0.111370441904753970375841475032e-17}
             ($2E2B,$4EFF,$C831,$BC3F),   {-0.172290580181768367727739031180e-17}
             ($92F8,$A24B,$B067,$3C21),   {+0.479463510149535766603385225170e-18}
             ($3228,$A31B,$7CE4,$BBDF));  {-0.266712580144022466545676300702e-19} *)
var
  fdp05_0: array[0..np05_0 - 1] of double absolute fdp05x0;
begin
  if x < ln_MinDbl then sfd_fdp05 := 0.0
  else if x<=0.0 then begin
    t := -exp(x);
    sfd_fdp05 := -sfd_polylogr(1.5,t);
  end
  else if x<=4.0 then begin
    t := 0.5*x - 1.0;
    sfd_fdp05 := CSEvalD(t,fdp05_0,np05_0);
  end
  else if x<=12.0 then begin
    t := 0.25*x - 2.0;
    sfd_fdp05 := CSEvalD(t,fdp05_1,np05_1);
  end
  else if x<=36.0 then begin
    t := x/12.0 - 2.0;
    sfd_fdp05 := CSEvalD(t,fdp05_2,np05_2)*(x*sqrt(x));
  end
  else sfd_fdp05 := fd_asymp_exp_real(0.5, x);
end;


{---------------------------------------------------------------------------}
function sfd_fdp15(x: double): double;
  {-Return the complete Fermi-Dirac integral F(3/2,x)}
var
  t: double;
{Note: THexExtW are needed with 16-bit compilers for relative errors}
{less than 5 eps_x, they are not needed for the 32+ bit compilers.}
const
  { t05 := t -> fd(3/2, 12*(t+2))/(12*(t+2))^(1/2);}
  { x=12*(t+2), x=12..36, t=x/12-2                 }
  { chebyshev(t05(t),t=-1..1,1e-20);               }
  np15_2 = 25;
  fdp15x2: array[0..np15_2 - 1] of THexDblW = (
             ($F23C,$9B09,$9AD5,$4078),  {+393.677149809696644142546727520     }
             ($53DA,$9D45,$AA41,$4065),  {+173.320509562878949028343254629     }
             ($912B,$37DB,$AA0F,$4035),  {+21.6642947112133422213067966255     }
             ($F1E1,$8588,$9E65,$3F2B),  {+0.210714237953170942219696358853e-3 }
             ($F85E,$9662,$D5BF,$BF12),  {-0.718496499727285184077531927810e-4 }
             ($3036,$D788,$DF7F,$3EF8),  {+0.237207836751159485396541754926e-4 }
             ($E281,$094D,$18F9,$BEE0),  {-0.767590999271980660146431767708e-5 }
             ($7A11,$05DB,$92CB,$3EC4),  {+0.245254163543031709270268343461e-5 }
             ($153E,$82BC,$124E,$BEAA),  {-0.776991560397809018284767617646e-6 }
             ($F6B4,$3639,$6894,$3E90),  {+0.244505875303265321902366760042e-6 }
             ($CDFC,$0F4F,$81EC,$BE74),  {-0.763964214804373133153424561594e-7 }
             ($8C06,$A6D7,$64E5,$3E59),  {+0.236501257934163191285570284659e-7 }
             ($E90F,$EAD9,$0C30,$BE3F),  {-0.722883767916310863735409648412e-8 }
             ($12E4,$0527,$A930,$3E22),  {+0.217241339606649724120320521755e-8 }
             ($EEFD,$B040,$F4B0,$BE05),  {-0.638998493447754354290912578799e-9 }
             ($4BDB,$8B70,$2C15,$3DE9),  {+0.183151887509753281847516506455e-9 }
             ($280D,$D06B,$00B7,$BDCC),  {-0.509368051664093473288607380309e-10}
             ($30B7,$8A22,$1A0D,$3DAE),  {+0.136886997541566136575665471750e-10}
             ($15E2,$5DE4,$21BF,$BD8F),  {-0.353927888170894587412962962963e-11}
             ($F3A6,$CF0B,$D135,$3D6E),  {+0.875878279963572878030001813229e-12}
             ($09C0,$6175,$FD89,$BD4C),  {-0.205989021488066426533527402068e-12}
             ($D72A,$904B,$9EF7,$3D29),  {+0.455119764481986405607195659516e-13}
             ($1309,$E0EE,$D216,$BD04),  {-0.924623115860204057417838398008e-14}
             ($54CF,$0181,$A541,$3CDD),  {+0.164565711952036018183311201810e-14}
             ($A6A4,$F29A,$C4F0,$BCAF)); {-0.220443812993426860139333865987e-15}
          (* ($7F94,$9BC8,$D9DB,$3C50),  {+0.365397972517501996244690383192e-17}
             ($E54C,$00A8,$5FA4,$3C6C),  {+0.123050858698337431875674263879e-16}
             ($4716,$BD60,$4821,$BC5D),  {-0.634947060808761965490670663525e-17}
             ($B10B,$5EBD,$EA6A,$3C45)); {+0.237610339158742466002499926615e-17}*)
var
  fdp15_2: array[0..np15_2 - 1] of double absolute fdp15x2;

const
  { t01 := t -> fd(3/2, 4*(t+2));    }
  { x = 4*(t+2), x=4..12, t = x/4-2  }
  { chebyshev(t01(t),t=-1..1,1e-20); }
  np15_1 = 24;
  fdp15x1: array[0..np15_1 - 1] of THexDblW = (
             ($C95A,$E9F9,$13E3,$4062),  {+144.621571529259032428771143927     }
             ($16BC,$E98C,$C497,$4051),  {+71.0717719905905466371272862772     }
             ($781B,$671F,$31F2,$4029),  {+12.5975525117792606809099721639     }
             ($E9B1,$7033,$B781,$3FE1),  {+0.553650588174880717832038589277    }
             ($41A4,$62E2,$BED7,$BF94),  {-0.202592519859209473857912236637e-1 }
             ($3593,$643C,$0D98,$3F5F),  {+0.189533121096316792767452098604e-2 }
             ($6E8A,$D634,$409D,$BF2F),  {-0.238436953716159989593353128291e-3 }
             ($E4C7,$C8B1,$5104,$3F00),  {+0.311212143850408587874050782270e-4 }
             ($5560,$9FDC,$3E3B,$BECC),  {-0.336683956348819682547767353618e-5 }
             ($0ACA,$7AB5,$F0FC,$3E80),  {+0.126222912436444848171965382239e-6 }
             ($72E9,$E259,$C7FA,$3E73),  {+0.736906079156018166644702930994e-7 }
             ($D2BB,$7B31,$481C,$BE60),  {-0.303270008211311283346663953153e-7 }
             ($EC38,$EDAB,$294B,$3E41),  {+0.799135995354008736875080842464e-8 }
             ($CFE2,$E20D,$5AF0,$BE1D),  {-0.170869974438337289914881320262e-8 }
             ($4A74,$21C5,$371B,$3DF5),  {+0.308722632328765994404137936729e-9 }
             ($23AB,$CB98,$E651,$BDC8),  {-0.452922642527112623192798558694e-10}
             ($3CA2,$5189,$9C98,$3D92),  {+0.423181045240805123278208194488e-11}
             ($5364,$C99D,$65AD,$3D55),  {+0.304072259462936746531305583976e-12}
             ($940C,$18F7,$EAE3,$BD54),  {-0.297255947618743879851851851852e-12}
             ($062E,$1799,$6DC3,$3D3C),  {+0.100999237845665579891216408335e-12}
             ($C645,$6A77,$2F88,$BD1D),  {-0.259220869581007366602779655524e-13}
             ($F303,$E76D,$0575,$3CF9),  {+0.555585140617882757619481874975e-14}
             ($12C6,$FC08,$EEC5,$BCD1),  {-0.995465293734704990462363181734e-15}
             ($7EFF,$BC32,$9281,$3CA3)); {+0.135810058346642295601252681531e-15}
          (* ($2B59,$7D8F,$DBCB,$BC60),  {-0.731124092175007355955890529507e-17}
             ($1EA2,$5D20,$260C,$BC50),  {-0.350167511223713638421908510300e-17}
             ($AB9D,$E7AC,$249C,$3C40),  {+0.175022964653982558085935504438e-17}
             ($A325,$E6B2,$BE0D,$BC23)); {-0.535118813814286426465825003605e-18} *)
var
  fdp15_1: array[0..np15_1 - 1] of double absolute fdp15x1;

const
  { t00 := t -> fd(3/2, 2*(t+1));    }
  { x = 2*(t+1), x=0..4, t = x/2 - 1 }
  { chebyshev(t00(t),t=-1..1,1e-20); }
  np15_0 = 25;
  fdp15x0: array[0..np15_0 - 1] of THexDblW = (
             ($A315,$C271,$78EA,$4026),  {+11.2361660731999487650196539022     }
             ($5325,$1CB8,$3DE8,$4018),  {+6.06045575022725316259549802070     }
             ($6B07,$CDE1,$2F59,$3FF7),  {+1.44906025335393602893404918865     }
             ($0A0A,$00F5,$8173,$3FC1),  {+0.136762977092147062390097045216    }
             ($53E9,$9E46,$45EE,$BF6C),  {-0.345131497506167132632284553539e-2 }
             ($426B,$796B,$75BE,$BF42),  {-0.563352589631871874123951841546e-3 }
             ($70E0,$E3F8,$43C1,$3F24),  {+0.154607218051056552536121778837e-3 }
             ($6A27,$DA20,$5269,$BEE9),  {-0.120744360323959578589830745772e-4 }
             ($5840,$0AC1,$D220,$BEC4),  {-0.248203294543183140475604723205e-5 }
             ($0F04,$D5D2,$FB41,$3EAC),  {+0.863715211033418489770376681673e-6 }
             ($4896,$5512,$CB82,$BE73),  {-0.737419629962366024649889011125e-7 }
             ($90CB,$A25A,$C7E1,$BE54),  {-0.193536157296765233417347973541e-7 }
             ($4053,$9EC5,$BC39,$3E3D),  {+0.692327837795870789793347218373e-8 }
             ($CFF0,$4719,$F0E4,$BE03),  {-0.580358995411251500567849837436e-9 }
             ($3577,$FCB8,$FCEC,$BDE9),  {-0.189087521994069533271266643381e-9 }
             ($7A7E,$AFD2,$4F70,$3DD2),  {+0.666125314244479449384812386092e-10}
             ($8633,$19A2,$12FE,$BD97),  {-0.524646333369187500930477271470e-11}
             ($DF89,$C15C,$76F9,$BD82),  {-0.209919886217411753402440640368e-11}
             ($BDE7,$D08F,$33CE,$3D69),  {+0.716294564761610784198888888888e-12}
             ($4641,$8CAE,$ED83,$BD2C),  {-0.513860750157027073244086281861e-13}
             ($6554,$EA3A,$7DDE,$BD1C),  {-0.253056976815591798244447365957e-13}
             ($AEFD,$157B,$AF5C,$3D02),  {+0.829780637050019897622756491845e-14}
             ($9DD4,$18A7,$F76B,$BCC2),  {-0.526425511792256252661083839711e-15}
             ($11DA,$FE24,$466C,$BCB7),  {-0.323006907293430828006534552996e-15}
             ($6A69,$BCF8,$3736,$3C9D)); {+0.101362248414592941198973611545e-15}
          (* ($2B8B,$4D12,$55EF,$BC59),  {-0.549380044372876769961972088020e-17}
             ($8A4B,$87F2,$D30E,$BC53),  {-0.429874028650913261261177926866e-17}
             ($27E4,$D76D,$C2A3,$3C37),  {+0.128804912282021759252165783078e-17}
             ($F877,$E943,$CB27,$BBF0),  {-0.568988546141851450939277082825e-19}
             ($8D23,$1D80,$6DBE,$BBF1)); {-0.590506721292714320278146535944e-19} *)
var
  fdp15_0: array[0..np15_0 - 1] of double absolute fdp15x0;
begin
  if x < ln_MinDbl then sfd_fdp15 := 0.0
  else if x<=0.0 then begin
    t := -exp(x);
    sfd_fdp15 := -sfd_polylogr(2.5,t);
  end
  else if x<=4.0 then begin
    t := 0.5*x - 1.0;
    sfd_fdp15 := CSEvalD(t,fdp15_0,np15_0);
  end
  else if x<=12.0 then begin
    t := 0.25*x - 2.0;
    sfd_fdp15 := CSEvalD(t,fdp15_1,np15_1);
  end
  else if x<=36.0 then begin
    t := x/12.0 - 2.0;
    sfd_fdp15 := CSEvalD(t,fdp15_2,np15_2)*sqrt(x);
  end
  else sfd_fdp15 := fd_asymp_exp_real(1.5, x);
end;


{---------------------------------------------------------------------------}
function sfd_fdp25(x: double): double;
  {-Return the complete Fermi-Dirac integral F(5/2,x)}
var
  t: double;
const
  { t05 := t -> fd(5/2, 12*(t+2))/(12*(t+2))^(1/2);}
  { x=12*(t+2), x=12..36, t=x/12-2                 }
  { chebyshev(t05(t),t=-1..1,0.5e-20);             }
  np25_2 = 28;
  fdp25x2: array[0..np25_2 - 1] of THexDblW = (
             ($4916,$DD6C,$FF99,$40A9),  {+3327.80051744835038169140925270     }
             ($A2E3,$72D4,$D3CD,$409D),  {+1908.95063335651571308582790355     }
             ($FD41,$D2D9,$DAF5,$407B),  {+445.685015536804785376765540320     }
             ($3A46,$7C92,$91A2,$4042),  {+37.1377711977006996644597888501     }
             ($C121,$FBAA,$F811,$3F41),  {+0.548371105955101354822268394464e-3 }
             ($6999,$FB46,$8B11,$BF23),  {-0.149103112232773501712826143475e-3 }
             ($0DB2,$4CB5,$5543,$3F05),  {+0.406895793170452009031534941051e-4 }
             ($B8EB,$AC20,$6299,$BEE7),  {-0.111509119769784098254022652378e-4 }
             ($7639,$323E,$C151,$3EC9),  {+0.307025256236664354012898996850e-5 }
             ($4572,$9D6A,$80DC,$BEAC),  {-0.849466512091940332152581052807e-6 }
             ($B0D8,$795D,$AF7A,$3E8F),  {+0.236075092526091114586850623705e-6 }
             ($C771,$FE7F,$AB1D,$BE71),  {-0.658200175472105542226242341390e-7 }
             ($6FA4,$1B51,$B9E4,$3E53),  {+0.183713965883408450720821603225e-7 }
             ($AA09,$A332,$FB69,$BE35),  {-0.511810198663846546954610261831e-8 }
             ($7BC9,$3FA3,$5CEF,$3E18),  {+0.141811473549707654091087714101e-8 }
             ($9AB5,$0675,$C109,$BDFA),  {-0.389322579781747804677424437470e-9 }
             ($94F3,$EA12,$014D,$3DDD),  {+0.105519921375420776489151857017e-9 }
             ($B4AA,$D74A,$F279,$BDBE),  {-0.281462886467752204120551871327e-10}
             ($D61A,$EEF4,$353D,$3DA0),  {+0.737053427612575970277777777777e-11}
             ($1D91,$4225,$A3A0,$BD80),  {-0.189165394872340800854140566911e-11}
             ($4D7C,$E305,$BA56,$3D60),  {+0.475435180287273717546904411718e-12}
             ($2AC6,$A8F8,$7830,$BD40),  {-0.117022782527244997933790212172e-12}
             ($A73B,$7EF5,$CA4D,$3D1F),  {+0.282354095607738906708933732942e-13}
             ($BAD8,$3563,$221F,$BCFE),  {-0.669093418553307654841147190614e-14}
             ($1837,$EEE9,$2221,$3CDC),  {+0.156171355182400009442588371477e-14}
             ($8635,$5FFD,$F8E0,$BCB9),  {-0.360436315380567126678385530540e-15}
             ($9551,$6D2A,$D2E6,$3C97),  {+0.826555092713945341135435212925e-16}
             ($6C6C,$B38E,$D5CE,$BC75)); {-0.189390042389614168443291988842e-16}
            {($A369,$C0F3,$1D4B,$3C54)}  {+0.436162329343858784694936828122e-17}
var
  fdp25_2: array[0..np25_2 - 1] of double absolute fdp25x2;

const
  { t01 := t -> fd(5/2, 4*(t+2));     }
  { x = 4*(t+2), x=4..12, t = x/4-2   }
  { chebyshev(t01(t),t=-1..1,0.5e-20);}
  np25_1 = 25;
  fdp25x1: array[0..np25_1 - 1] of THexDblW = (
             ($EFF7,$81AA,$E407,$407B),  {+446.251832645153130169370289260     }
             ($D1D8,$C387,$80C4,$4070),  {+264.048038034959543495722343526     }
             ($AEE8,$E6AB,$A128,$4051),  {+70.5181214024156659192952476879     }
             ($F0D2,$3735,$D2E1,$4020),  {+8.41187450917678775219717559168     }
             ($CB97,$A401,$A7FA,$3FD1),  {+0.275877628481958774952182034146    }
             ($7A39,$5291,$66AB,$BF80),  {-0.800832601288191495847914821399e-2 }
             ($6EF4,$7EA4,$5CB5,$3F44),  {+0.621403332192709022962371969718e-3 }
             ($B543,$A8F9,$9B39,$BF11),  {-0.671628897579062265051072717362e-4 }
             ($2FBC,$CC37,$4013,$3EE0),  {+0.774874786815110348480827930088e-5 }
             ($8F15,$30D4,$A78A,$BEA9),  {-0.764562260311955253809364235157e-6 }
             ($992D,$1467,$CF36,$3E60),  {+0.313099826515151953013264804033e-7 }
             ($F08F,$06BF,$A702,$3E49),  {+0.119453178112839507810392037265e-7 }
             ($85A5,$F02C,$7C5B,$BE34),  {-0.476971684612462590592051464946e-8 }
             ($0254,$DE4C,$4E3E,$3E14),  {+0.118194420326328021143663686090e-8 }
             ($0870,$C21C,$546C,$BDF0),  {-0.237629640018665948118995031809e-9 }
             ($B08A,$1198,$51C5,$3DC6),  {+0.405987762501810590898667771913e-10}
             ($5E51,$272B,$111D,$BD99),  {-0.569954206402177488280324465353e-11}
             ($7E02,$6C53,$BF51,$3D62),  {+0.532831341179622954769972002079e-12}
             ($0348,$EA29,$6788,$3D19),  {+0.225636690685856850370370370370e-13}
             ($D08D,$D986,$1423,$BD20),  {-0.285614590169098049435176590815e-13}
             ($8597,$C74E,$7DEF,$3D05),  {+0.954433864394867464106024538843e-14}
             ($5938,$FBF9,$61FC,$BCE5),  {-0.237396396803486035394564496255e-14}
             ($4520,$4120,$C0A4,$3CC1),  {+0.492731031621107824201139948487e-15}
             ($96DD,$8C97,$C440,$BC98),  {-0.859264393750395508067640840442e-16}
             ($552C,$7ECF,$C4ED,$3C6A)); {+0.116093111215732467860177907410e-16}
            {($6AFC,$5140,$BEA7,$BC2A)}  {-0.724917645463107688269430437231e-18}
var
  fdp25_1: array[0..np25_1 - 1] of double absolute fdp25x1;

const
  { t00 := t -> fd(5/2, 2*(t+1));     }
  { x = 2*(t+1), x=0..4, t = x/2 - 1  }
  { chebyshev(t00(t),t=-1..1,0.5e-20);}
  np25_0 = 25;
  fdp25x0: array[0..np25_0 - 1] of THexDblW = (
             ($EF17,$9E50,$6772,$4030),  {16.4040926883309016968622975910      }
             ($75B4,$88B5,$92FF,$4023),  {+9.78710581984601273608560471355     }
             ($AAD5,$84B0,$B1DC,$4007),  {+2.96184638656755305010270048774     }
             ($BD96,$5C40,$FCA6,$3FDE),  {+0.484170522776332566753457344729    }
             ($754C,$BF6E,$93E8,$3FA1),  {+0.343315824204447335660552492644e-1 }
             ($AF2C,$CA04,$A1BB,$BF47),  {-0.721184438622545575771793462833e-3 }
             ($ABAE,$1803,$15F1,$BF18),  {-0.918796922665793193774947944856e-4 }
             ($8725,$E028,$880B,$3EF7),  {+0.224413215709269119915539751533e-4 }
             ($8B17,$F77D,$221D,$BEBB),  {-0.161726890542867204359418139982e-5 }
             ($938A,$F8F9,$F51F,$BE91),  {-0.267587886937288311365673143759e-6 }
             ($4FA2,$1BEA,$B467,$3E77),  {+0.883068826763095013112111498740e-7 }
             ($E3CA,$5BA0,$7EF1,$BE3F),  {-0.733320376129048276026566510888e-8 }
             ($ADB9,$AAD7,$E078,$BE1A),  {-0.156443806118877265343058350412e-8 }
             ($B276,$17CB,$CC63,$3E02),  {+0.547105069227136725477278628827e-9 }
             ($FF25,$D816,$67CB,$BDC9),  {-0.462122519168356746790325305029e-10}
             ($67C2,$EA94,$F38D,$BDAA),  {-0.122560705773585105508047077120e-10}
             ($617B,$7DDD,$E328,$3D92),  {+0.429448314291387890453274064781e-11}
             ($B2C4,$037C,$AE8F,$BD58),  {-0.350750464614910929036192564942e-12}
             ($7780,$D825,$02E6,$BD40),  {-0.113767377064356379270370370370e-12}
             ($E5F4,$9AD8,$F90B,$3D25),  {+0.390315927601668402160150340116e-13}
             ($2800,$41A4,$E115,$BCEA),  {-0.298419406931014531473839059196e-14}
             ($5BBB,$31DF,$41A1,$BCD5),  {-0.117996534141747254896765099982e-14}
             ($E812,$9F29,$3C73,$3CBC),  {+0.391855148990619535770411408698e-15}
             ($EE15,$F540,$7818,$BC7F),  {-0.272951200089934340373538288281e-16}
             ($618C,$ABEA,$8171,$BC6E)); {-0.132297127854042464240388752538e-16}
           (*($49A3,$F942,$7DB2,$3C53),  {+0.422643954804408384069683831290e-17}
             ($0DBA,$9F57,$3F22,$BC13),  {-0.260840367944197757647285622463e-18}
             ($3C19,$A18B,$2F44,$BC07),  {-0.157105238218333575135078217011e-18}
             ($C0FD,$D3BC,$6648,$3BEC)); {+0.481107069624679302676225882053e-19}*)
var
  fdp25_0: array[0..np25_0 - 1] of double absolute fdp25x0;
begin
  if x < ln_MinDbl then sfd_fdp25 := 0.0
  else if x<=0.0 then begin
    t := -exp(x);
    sfd_fdp25 := -sfd_polylogr(3.5,t);
  end
  else if x<=4.0 then begin
    t := 0.5*x - 1.0;
    sfd_fdp25 := CSEvalD(t,fdp25_0,np25_0);
  end
  else if x<=12.0 then begin
    t := 0.25*x - 2.0;
    sfd_fdp25 := CSEvalD(t,fdp25_1,np25_1);
  end
  else if x<=36.0 then begin
    t := x/12.0 - 2.0;
    sfd_fdp25 := CSEvalD(t,fdp25_2,np25_2)*sqrt(x);
  end
  else sfd_fdp25 := fd_asymp_exp_real(2.5, x);
end;


{---------------------------------------------------------------------------}
function sfd_fdm05(x: double): double;
  {-Return the complete Fermi-Dirac integral F(-1/2,x)}
var
  t: double;
{Note: THexDblW are needed with 16-bit compilers for relative errors}
{less than 5 eps_d, they are not needed for the 32+ bit compilers.}
const
  { t05 := t -> fd(-1/2, 14*(t+2)-2)/(14*(t+2)-2)^(1/2); }
  { x = 14*(t+2)-2, x=12..40, t = (x+2)/14-2             }
  { chebyshev(t05(t),t=-1..1,1e-20);                     }
  nm05_2 = 31;
  fdm05x2: array[0..nm05_2 - 1] of THexDblW = (
             ($1167,$E52B,$090B,$4002),   {+2.25441721952136085970252062938     }
             ($02BE,$26C8,$DD8B,$3F54),   {+0.127352322590483468748105626469e-2 }
             ($1A18,$7305,$0B10,$BF42),   {-0.550635368235688347038739063159e-3 }
             ($85BA,$93A2,$4446,$3F2C),   {+0.215657821006449458356062287107e-3 }
             ($05C3,$90F9,$FCA3,$BF14),   {-0.800585587450641857019601765123e-4 }
             ($F223,$EB7E,$2E1C,$3EFE),   {+0.287820136859342153053116112911e-4 }
             ($EC4A,$0712,$450F,$BEE5),   {-0.101422121779796149201023928609e-4 }
             ($0A03,$F467,$9A24,$3ECD),   {+0.352884845542076071119669637285e-5 }
             ($0422,$A961,$6E2E,$BEB4),   {-0.121774670482100079163136672498e-5 }
             ($E019,$ABDF,$085B,$3E9C),   {+0.417719018374740984434001320844e-6 }
             ($9175,$E663,$1FB6,$BE83),   {-0.142484043403418353187352871031e-6 }
             ($6BA7,$2F39,$E963,$3E69),   {+0.482642458470626719951342032248e-7 }
             ($CB1C,$839B,$62BE,$BE51),   {-0.161917130596971286058653227519e-7 }
             ($70C0,$26E4,$05A7,$3E37),   {+0.536024612047194258605653270535e-8 }
             ($24C1,$E7C5,$F52D,$BE1D),   {-0.174376948911707269461907228582e-8 }
             ($F266,$DA53,$120F,$3E03),   {+0.555026181833641050021767137440e-9 }
             ($A915,$DE6C,$A705,$BDE7),   {-0.172094102173839496709895590169e-9 }
             ($5856,$19B8,$73D6,$3DCC),   {+0.517547699271684434423133548903e-10}
             ($B194,$8448,$85A1,$BDB0),   {-0.150266676426121966101287037037e-10}
             ($BDCC,$0C56,$6CE6,$3D92),   {+0.418944756732711716944423047911e-11}
             ($D8F5,$D7A4,$96B5,$BD73),   {-0.111348937219875590656629403579e-11}
             ($244D,$0866,$A185,$3D53),   {+0.278972381829081126481744940963e-12}
             ($7FF0,$9737,$2BA7,$BD32),   {-0.645546762036873772076350520773e-13}
             ($6853,$D33C,$B74B,$3D0D),   {+0.131965552928934103834300756587e-13}
             ($FBDB,$953C,$CD21,$BCE2),   {-0.208736291421929647980739225035e-14}
             ($872A,$0309,$2C56,$3C99),   {+0.873370384238809757090654794064e-16}
             ($E9B5,$2607,$9341,$3CA1),   {+0.121952537222219205275296984895e-15}
             ($9686,$2E06,$CE60,$BC95),   {-0.756552983007583718512206829240e-16}
             ($D1B0,$45BC,$CCBB,$3C82),   {+0.326123373969832726648499559418e-16}
             ($2D27,$BDFC,$282A,$BC6C),   {-0.122111098113026111719660711879e-16}
             ($DDF3,$E97D,$89EB,$3C53));  {+0.423679233680363253635062387618e-17}
         (*  ($FE4C,$B7F7,$D9F0,$BC39),   {-0.140140337077744622807440276665e-17}
             ($8850,$3785,$8D71,$3C20),   {+0.448656650094168829272055386020e-18}
             ($CA37,$5941,$B33E,$BC04),   {-0.140269808809750966318869781429e-18}
             ($78A2,$64B0,$6B20,$3BE9),   {+0.430605513146981698934338690424e-19}
             ($DF5A,$EF45,$BF70,$BBCE));  {-0.130222070259439058246940543349e-19} *)
var
  fdm05_2: array[0..nm05_2 - 1] of double absolute fdm05x2;

const
  { t01 := t -> fd(-1/2, 4*(t+2));   }
  { x = 4*(t+2), x=4..12, t = x/4-2  }
  { chebyshev(t01(t),t=-1..1,1e-20); }
  nm05_1 = 28;
  fdm05x1: array[0..nm05_1 - 1] of THexDblW = (
             ($E6D0,$6D50,$DB90,$4018),   {+6.21441813284191387098283326126     }
             ($F949,$E14B,$0D15,$3FEB),   {+0.845347347290762745698264830651    }
             ($A264,$AE88,$50EA,$BFB0),   {-0.637346912486776414955579558212e-1 }
             ($EFE9,$BF56,$875E,$3F84),   {+0.100238229887210249047746267365e-1 }
             ($67B6,$CD64,$8BD7,$BF5E),   {-0.186439585156115756577336126739e-2 }
             ($0EE9,$DEEE,$87F7,$3F35),   {+0.328538909279736813909986738098e-3 }
             ($1AA9,$2F93,$CE0A,$BF06),   {-0.434967859717546117551553285448e-4 }
             ($CAB5,$28E1,$0718,$3EA4),   {+0.596872341564135171934135718907e-6 }
             ($A0DA,$ACA2,$3C65,$3EC2),   {+0.217389183372963314012513808309e-5 }
             ($1838,$2BBC,$2483,$BEB0),   {-0.962175518760746788464909336684e-6 }
             ($BF8B,$6BF5,$79FC,$3E93),   {+0.290222583707548004030466363153e-6 }
             ($6D74,$2D72,$0D02,$BE73),   {-0.709698143468401550945013829553e-7 }
             ($B279,$F424,$0901,$3E4F),   {+0.144518846929383515210221101027e-7 }
             ($34B1,$0600,$E088,$BE23),   {-0.231399614747943009400043966811e-8 }
             ($57A8,$4CD3,$0D04,$3DEC),   {+0.204096772826715027518323729570e-9 }
             ($5937,$E7FD,$3B49,$3DC5),   {+0.386200489979488286568147019637e-10}
             ($F85E,$BC05,$7A93,$BDBE),   {-0.277203223495739126097345324431e-10}
             ($0D8F,$C184,$8663,$3DA5),   {+0.978841838084900111240803825558e-11}
             ($0C97,$EB5F,$9A25,$BD87),   {-0.268325278562056093253240740740e-11}
             ($6B6E,$D40A,$9DAD,$3D65),   {+0.614361785526356233322403621196e-12}
             ($D29B,$FE25,$5463,$BD40),   {-0.116029147310593134362697691583e-12}
             ($6337,$80E3,$E4E4,$3D11),   {+0.158931638394253582586663743109e-13}
             ($2B56,$0FB3,$24CA,$BCBC),   {-0.390572410679751374699284640444e-15}
             ($21D3,$A14F,$FE80,$BCC9),   {-0.721482602544015576484549245755e-15}
             ($1A6E,$46F3,$20B7,$3CB8),   {+0.334840441309012455905148106174e-15}
             ($2AA2,$9BE1,$322C,$BC9E),   {-0.104763396492153632437572704125e-15}
             ($F986,$2505,$B8AB,$3C7E),   {+0.266465334690489637299281537629e-16}
             ($584D,$08AD,$29A6,$BC5A));  {-0.567312900783804305906703267603e-17}
         (*  ($B40D,$83CF,$C0E1,$3C31),   {+0.962415969624123143993085069845e-18}
             ($4C2E,$32DA,$EBD8,$BBFC));  {-0.979890664035765026812190968018e-19} *)
var
  fdm05_1: array[0..nm05_1 - 1] of double absolute fdm05x1;

const
  { t00 := t -> fd(-1/2, 2*(t+1));   }
  { x = 2*(t+1), x=0..4, t = x/2 - 1 }
  { chebyshev(t00(t),t=-1..1,1e-20); }
  nm05_0 = 29;
  fdm05x0: array[0..nm05_0 - 1] of THexDblW = (
             ($4E99,$830F,$CEAC,$4006),   {+2.85091497793639472284857657018     }
             ($117E,$7A76,$B0A2,$3FE9),   {+0.802811850721397311632302091077    }
             ($CE77,$4833,$90BD,$BFA1),   {-0.343073988568933129244642294564e-1 }
             ($399F,$0089,$8836,$BF88),   {-0.119785517610154200513442344857e-1 }
             ($C6D8,$E630,$F817,$3F71),   {+0.438699088685875336070850350529e-2 }
             ($9D48,$9B9C,$73D0,$BF3A),   {-0.403631620076134737472343018429e-3 }
             ($80C2,$714E,$7C2B,$BF23),   {-0.148659041454562690460518932844e-3 }
             ($9D2D,$FC7D,$7F90,$3F0E),   {+0.581709023766370096169389361999e-4 }
             ($C2F8,$D062,$3F57,$BED5),   {-0.506578294882995558003563539688e-5 }
             ($1B68,$4C4D,$F712,$BEC2),   {-0.226081883384096770040396740859e-5 }
             ($7AF4,$445D,$721B,$3EAC),   {+0.847748773163128123864631556434e-6 }
             ($6B4D,$50EE,$BE73,$BE71),   {-0.661013539307752677486955427753e-7 }
             ($7C83,$0B43,$71AA,$BE63),   {-0.362172739869069536282661782116e-7 }
             ($64A8,$F857,$AA24,$3E4B),   {+0.128823456441545703286380320048e-7 }
             ($ECCE,$F463,$FEEE,$BE0D),   {-0.872993657208158587706978751116e-9 }
             ($9BF1,$0AC5,$74AF,$BE04),   {-0.595342016608391684486334590438e-9 }
             ($73E7,$27B4,$8E11,$3DEB),   {+0.200488642920464472125344875726e-9 }
             ($1FD1,$6112,$150E,$BDA9),   {-0.114060870414129142501077323872e-10}
             ($F1D5,$69F7,$D988,$BDA5),   {-0.993611036461939592748999999999e-11}
             ($2E50,$C432,$DB68,$3D8B),   {+0.316698189615823685519545765746e-11}
             ($58E0,$A258,$4346,$BD44),   {-0.143975828889301436878708068523e-12}
             ($74A6,$CC92,$9038,$BD47),   {-0.167427790285290702945465438147e-12}
             ($D23B,$B1F8,$7038,$3D2C),   {+0.505166843470001025439981895705e-13}
             ($CD0A,$9016,$7A85,$BCDE),   {-0.169190220207909386709653151896e-14}
             ($6EF5,$9793,$9252,$BCE9),   {-0.283901488488463908424013117515e-14}
             ($61E4,$8C25,$38D1,$3CCD),   {+0.811071971814294943755263204708e-15}
             ($DF9A,$5337,$96E2,$BC73),   {-0.169910881775102181849224823698e-16}
             ($2703,$7365,$DE29,$BC8B),   {-0.483429615582375261924591357742e-16}
             ($24B6,$316A,$2870,$3C6E));  {+0.130789311367733023108178561868e-16}
         (*  ($5886,$8BBD,$FC9C,$BBFD),   {-0.101599107342478990354348239320e-18}
             ($5A76,$4BED,$74BA,$BC2E),   {-0.825510657563228475743326075971e-18}
             ($D018,$A7EC,$35DF,$3C0F),   {+0.211490194721918999612264245007e-18}
             ($B493,$9D86,$AC53,$BBD0));  {-0.141227081204025177342262136401e-19} *)
var
  fdm05_0: array[0..nm05_0 - 1] of double absolute fdm05x0;
begin
  if x < ln_MinDbl then sfd_fdm05 := 0.0
  else if x<=0.0 then begin
    t := -exp(x);
    sfd_fdm05 := -sfd_polylogr(0.5,t);
  end
  else if x<=4.0 then begin
    t := 0.5*x - 1.0;
    sfd_fdm05 := CSEvalD(t,fdm05_0,nm05_0);
  end
  else if x<=12.0 then begin
    t := 0.25*x - 2.0;
    sfd_fdm05 := CSEvalD(t,fdm05_1,nm05_1);
  end
  else if x<=40.0 then begin
    t := (x+2.0)/14.0 - 2.0;
    sfd_fdm05 := CSEvalD(t,fdm05_2,nm05_2)*sqrt(x);
  end
  else sfd_fdm05 := fd_asymp_exp_real(-0.5, x);
end;


{---------------------------------------------------------------------------}
function sfd_harmonic(x: double): double;
  {-Return the harmonic function H(x) = psi(x+1) + EulerGamma}
const
  nch = 20;
  chah: array[0..nch-1] of THexDblW = (    {chebyshev((Psi(x+1)+gamma)/x, x=-1/4..1/4, 0.2e-20);}
          ($4D5F,$8EB2,$E29F,$400A),  {+3.36065589410433977112951870486     }
          ($7CEC,$1B06,$0D61,$BFD4),  {-0.313316608802735484720854737533    }
          ($8810,$97A0,$65A0,$3FA2),  {+0.359316048709531508723414593246e-1 }
          ($3029,$759F,$F05E,$BF71),  {-0.437962434984843410853415224307e-2 }
          ($EAF5,$9C6A,$E6A2,$3F41),  {+0.546292686372267141546977073957e-3 }
          ($9261,$A627,$09E1,$BF12),  {-0.688117957348770917553696097164e-4 }
          ($7B52,$CCBB,$41EB,$3EE2),  {+0.870585645123897195412611399047e-5 }
          ($E225,$62DD,$8458,$BEB2),  {-0.110369763769828900468418914839e-5 }
          ($BA65,$0424,$CC67,$3E82),  {+0.140059343742157854915062263457e-6 }
          ($6CD6,$EE71,$17D9,$BE53),  {-0.177818994219795504449052141370e-7 }
          ($5ADF,$10A2,$659E,$3E23),  {+0.225810137695486223694241640848e-8 }
          ($F21E,$2F91,$B52F,$BDF3),  {-0.286785525509693105456693572379e-9 }
          ($60E6,$99FE,$064E,$3DC4),  {+0.364246022659874814089675465140e-10}
          ($9338,$DF9D,$58DF,$BD94),  {-0.462640992702404867971084536579e-11}
          ($4581,$93F6,$ACD7,$3D64),  {+0.587623516675841187923320281923e-12}
          ($0367,$CDDD,$0232,$BD35),  {-0.746374969291138217069111742907e-13}
          ($8D00,$EF8E,$58F2,$3D05),  {+0.948017526953988879040131837225e-14}
          ($3174,$8CDC,$B11B,$BCD5),  {-0.120413826871905020093317205030e-14}
          ($691B,$5EB8,$0AB1,$3CA6),  {+0.152945496208458532222222222222e-15}
          ($6621,$BD17,$65B9,$BC76));  {-0.194266177768451363581139754366e-16}
       (* ($DC15,$5BF2,$C23A,$3C46),  {+0.246750352250719046709039799083e-17}
          ($2AF8,$29E9,$2039,$BC17),  {-0.313414011663104260448782764313e-18}
          ($CEB4,$3FB3,$7FBC,$3BE7),  {+0.398087971944463065142369984751e-19}
          ($BBEB,$D80F,$E0C9,$BBB7)); {-0.505638009703096728955241279549e-20} *)
var
  cha: array[0..nch-1] of double absolute chah;
var
  y: double;
begin
  if IsNanOrInfD(x) then begin
    if x=PosInf_d then sfd_harmonic := PosInf_d
    else sfd_harmonic := NaN_d;
  end
  else if frac(x)=0.0 then begin
    if x<0.0 then begin
      {$ifopt R+}
        if RTE_ArgumentRange>0 then RunError(byte(RTE_ArgumentRange));
      {$endif}
      sfd_harmonic := Nan_d;
    end
    else if x<=12.0 then begin
      {sfd_psi uses a similar loop, avoid (y - EulerGamma) + EulerGamma}
      y := 0.0;
      while x>=1.0 do begin
        y := y + 1.0/x;
        x := x - 1.0;
      end;
      sfd_harmonic := y;
    end
    else sfd_harmonic := sfd_psi(x+1.0) + EulerGamma;
  end
  else begin
    if abs(x)<=0.25 then begin
      y := CSEvalD(4.0*x, cha, nch);
      sfd_harmonic := y*x;
    end
    else begin
      y := sfd_psi(x+1.0);
      sfd_harmonic :=  y + EulerGamma;
    end;
  end;
end;


{---------------------------------------------------------------------------}
function harm2core(x,r: double): double;
  {-Core routine for H(x,r), x >= -1, no checks, r<>0,1,-1}
  { The alternative computations use Hurwitz zeta or series for |x|<0.5}
var
  a,s,t: double;
  k: integer;
begin
  {Get threshold value for series}
  if r > 1.0 then t := 0.125 else t := 0.5;
  if abs(x)<=t then begin
    {http://functions.wolfram.com/06.17.06.0018.01 for z0=0, note that in}
    {.../06.17.06.0002.01 there are the restriction Re(r) > 1 and |x| < 1}
    a := r*x;
    s := a*sfd_zeta1p(r);
    k := 1;
    repeat
      a := (r+k)*x*a;
      k := k+1;
      a := -a/k;
      t := s;
      s := t + a*sfd_zeta(r+k);
    until t=s;
    harm2core := s;
  end
  else begin
    s := sfd_zeta(r);
    a := sfd_zetah(r, x+1.0);
    harm2core := s - a;
  end;
end;


{---------------------------------------------------------------------------}
function sfd_harmonic2(x,r: double): double;
  {-Return the generalized harmonic function H(x,r) = zeta(r)-zetah(r,x+1); x >= -1}
const
  XREC = 20.0;  {Max x for recursive call}
var
  a,s,t: double;
  n: integer;
begin
  if IsNanOrInfD(x) or IsNanOrInfD(x) or (x < -1.0) then begin
    {$ifopt R+}
      if RTE_ArgumentRange>0 then RunError(byte(RTE_ArgumentRange));
    {$endif}
    sfd_harmonic2 := NaN_d;
    exit;
  end;

  if (frac(x)=0.0) and (x <= 6.0)  then begin
    {Direct summation with exp<x> functions for small integer x}
    n := round(x);
    if n<2 then sfd_harmonic2 := n
    else if n=2 then sfd_harmonic2 := 1.0 + exp2(-r)
    else begin
      a := exp2(-r);
      s := exp3(-r);
      {Avoid brain-damaged Delphi warning: t IS defined for n=5!}
      if n>4 then t := exp5(-r) {$ifdef DELPHI}else t:=0.0{$endif};
      case n of
          3: sfd_harmonic2 := 1.0 + a + s;
          4: sfd_harmonic2 := 1.0 + a + s + a*a;
          5: sfd_harmonic2 := 1.0 + a + s + a*a + t;
        else sfd_harmonic2 := 1.0 + a + s + a*a + t + s*a;
      end;
    end;
  end
  else if (r<=1.0) and (r > -MaxInt) and (frac(r)=0.0)  then begin
    {r integer <= 1}
    n := 1 - round(r);
    if n=0 then begin
      {r=1, ordinary harmonic number function}
      sfd_harmonic2 := sfd_harmonic(x);
    end
    else begin
      {http://functions.wolfram.com/06.17.27.0005.01}
      a := sfd_bernoulli(n);
      if n and 1 = 0 then a := -a;
      s := sfd_bernpoly(n, x + 1.0);
      sfd_harmonic2 := (s+a)/n;
    end;
  end
  else if (-1.0 < x) and (x < -0.5) then begin
    {http://functions.wolfram.com/06.17.16.0004.01}
    {This is a critical range with possible cancellation: e.g.}
    {the relative error for H(-0.75, -3.5) is about 3.8E-18.}
    t := x + 1.0;
    s := harm2core(t,r);
    a := power(t,-r);
    sfd_harmonic2 := s - a;
  end
  else if (x > 0.5) and (x <= XREC) then begin
    {http://functions.wolfram.com/06.17.16.0005.01}
    {Make |x| <= 0.5}
    s := 0.0;
    repeat
      s := s + power(x,-r);
      x := x - 1.0;
    until x <= 0.5;
    a := harm2core(x,r);
    sfd_harmonic2 := s + a;
  end
  else begin
    {No special case or recursion}
    sfd_harmonic2 := harm2core(x,r);
  end;
end;


{---------------------------------------------------------------------------}
function sfd_llci(x: double): double;
  {-Return the Lobachevski function L(x) = integral(-ln(|cos(t)|), t=0..x)}
const
  lobpi2 = -1.482846963978694993e-4; {lower bits L(Pi)=Pi*ln(2)}
  lbpb22 = -7.414234819893474966e-5; {lower bits L(Pi)/2}
  pi2    = 9.676535897932384626e-4;  {lower bits Pi}
  piby22 = 4.838267948966192313e-4;  {lower bits Pi/2}
const
  lobpi1 : single = 1115.0/512.0;    {2.177734375}  {upper bits L(Pi)}
  pi1    : single = 201.0/64.0;      {3.140625}     {upper bits Pi}
const
  nl1=13;
  arlob1 : array[0..nl1-1] of double = (
             0.3446488495348130051,
             0.584198357190277669e-2,
             0.19175029694600330e-3,
             0.787251606456769e-5,
             0.36507477415804e-6,
             0.1830287272680e-7,
             0.96890333005e-9,
             0.5339055444e-10,
             0.303408025e-11,
             0.17667875e-12,
             0.1049393e-13,
             0.63359e-15,
             0.3878e-16);
           { 0.240e-17,
             0.15e-18,
             0.1e-19);}
  nl2=9;
  arlob2 : array[0..nl2-1] of double = (
             2.034594180361328511,
             0.1735185882027407681e-1,
             0.5516280426090521e-4,
             0.39781646276598e-6,
             0.369018028918e-8,
             0.3880409214e-10,
             0.44069698e-12,
             0.527674e-14,
             0.6568e-16);
           { 0.84e-18,
             0.1e-19);}
const
  xlow1 = 8.719671245e-17;       {Pi/4*eps/2}
  xlow2 = 4.71216091e-8;         {sqrt(10*eps)}
  xlow3 = 6.32202727e-8;         {sqrt(18*eps)}
  xhigh = 4.503599627370496e15;  {1/eps}
var
  xr,fval,xcub,t,npi: double;
  sx: integer;
  gtpi2: boolean;
begin

  {Ref: MISCFUN [22], function LOBACH}
  sx := isign(x);
  xr := abs(x);

  if xr >= xhigh then begin
    {Contribution from reduced x is negligible compared to x*ln(2)}
    {Note that Miscfun returns an error for these cases}
    sfd_llci := ln2*x;
    exit;
  end;

  {Reduce argument to [0,pi]}
  npi := int(xr/pi);
  xr  := (xr - npi*pi1) - npi*pi2;

  {Reduce argument to [0,pi/2]}
  gtpi2 := xr > pi_2;
  if gtpi2 then xr := (pi1 - xr) + pi2;

  {Code for argument in [0,pi/4]}
  if xr <= Pi_4 then begin
    xcub := xr*xr*xr;
    if xr < xlow2 then fval := xcub/6.0
    else begin
      t := 2.0*sqr(xr/Pi_4) - 1.0;
      t := CSEvalD(t, arlob1, nl1);
      fval := t*xcub;
    end;
  end
  else begin
    {Code for argument in [pi/4,pi/2]}
    xr := (0.5*pi1 - xr) + piby22;
    if xr < xlow3 then begin
      if xr < xlow1 then begin
        {Reduction may produce negative or very small positive values,}
        {the Miscfun test xr=0 does not catch them, e.g. for x=Pi_2   }
        {extended: xr = -2.517276040e-20, double: xr = 6.123224999e-17}
        fval := 0.0;
      end
      else fval := xr*(1.0 - ln(xr))
    end
    else begin
      t := 2.0*sqr(xr/Pi_4) - 1.0;
      t := CSEvalD(t, arlob2, nl2);
      fval := (t - ln(xr))*xr;
    end;
    fval := (0.5*lobpi1 - fval) + lbpb22;
  end;

  {Compute value for argument in [pi/2,pi]}
  if gtpi2 then fval := (lobpi1 - fval) + lobpi2;

  {Add quasi-periodic contribution}
  if npi > 0.0 then fval := (fval + npi*lobpi2 ) + npi*lobpi1;

  {Adjust sign}
  sfd_llci := sx*fval;
end;


{---------------------------------------------------------------------------}
function sfd_llsi(x: double): double;
  {-Return the Lobachevski function Lambda(x) = integral(-ln(|2sin(t)|), t=0..x)}
begin
  {http://mathworld.wolfram.com/LobachevskysFunction.html}
  {Lambda(x) = 0.5*cl_2(2x) = Im(polylog(2, exp(2ix)))/2}
  sfd_llsi := 0.5*sfd_cl2(2.0*x);
end;

end.
